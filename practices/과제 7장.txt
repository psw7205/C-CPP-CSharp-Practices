문제 1
#include<stdio.h>
#pragma warning(disable:4996)

int main()
{
	int a[10] = { 0 }, e[10] = { 0 }, o[10] = { 0 }; // 최대 10개의 정수를 입력받으므로 입력받을 배열 a[10]을 선언했습니다. 마찬가지로 짝수와 홀수의 갯수로 최대 10개이므로 크기를 10으로 정했습니다.
	int n, i, j = -1, k = -1; // 몇 개를 입력받을지 정할 변수 n과 반복문에 사용할 변수 i, 짝수와 홀수 배열 인덱스를 저장할 j, k입니다.
	//j와 k는 밑에서 먼저 증가시키고 값을 저장하기 때문에 -1로 초기화합니다. 
	scanf("%d", &n); // 최대 몇 개의 숫자를 입력받을지 정합니다.

	for (i = 0; i < n; i++)
		scanf("%d", &a[i]); // n번 반복문을 돌려 배열에 저장합니다.

	for (i = 0; i < n; i++)
	{
		if (a[i] % 2 == 0) // a[i]가 짝수라면 e 배열에 순서대로 저장합니다.
		{
			j++; // 인덱스를 1증가시킵니다
			e[j] = a[i]; // e배열 j번째에 짝수를 저장합니다.
		}
		else // 2로 나누어 떨어지지 않는다면 홀수입니다. 
		{
			k++; // 인덱스를 1증가시킵니다
			o[k] = a[i]; // o배열 k번째에 짝수를 저장합니다.
		}
	}

	printf("Even:\n");
	
	if (j == -1) // 짝수가 한번도 없었다면 j는 맨 처음 초기화 한 -1입니다.
		printf( "none\n" );
	else
	{
		for (i = 0; i <= j; i++) // i를 j번 반복하며 배열 e에 저장된 짝수를 출력합니다.
			printf("%d\n", e[i]);
	}


	printf("Odd:\n");

	if (k == -1) // 홀수 또한 한번도 없었다면 k는 맨 처음 초기화 한 -1입니다.
		printf("none\n");
	else
	{
		for (i = 0; i <= k; i++)// i를 k번 반복하며 배열 o에 저장된 홀수를 출력합니다.
			printf("%d\n", o[i]);
	}

	return 0;
}

=====================================================================================================================================================================================================================
문제 2

#include<stdio.h>
#pragma warning(disable:4996)

int main()
{
	int a[10] = { 0 }; //정수 10개를 입력받을 배열 a입니다. 
	int cnt[10] = { 0 }, i, j; //몇번 등장했을지 세는 cnt배열과 반복문에서 사용할 i, j입니다.

	for (i = 0; i < 10; i++)
		scanf("%d", &a[i]); // 반복문을 이용해 배열에 정수를 저장합니다.

	for (i = 0; i < 10; i++)
	{
		for (j = i; j < 10; j++) // 2중반복문을 통해 중복을 검사하고 cnt배열에 카운트를 저장합니다.
		{
			if (a[i] == a[j]) // 앞에서 부터 중복을 찾으므로 중복숫자 중 제일 먼저 나온 숫자만 제대로 카운트가 됩니다.
				cnt[i]++; // 1씩 카운트를 증가시킵니다.
		}
	}
	
	for (i = 0; i < 10; i++)
	{
		for (j = 0; j < 10; j++) // 다시 2중반복문을 통해 중첩된 숫자를 찾고 처음을 제외한 나머지 중복숫자는 출력하지 않습니다.
		{
			if (a[i] == a[j]) // 중복된 숫자가 발견하면 반복문을 탈출합니다.
				break;
		}
		if (i == j) // 중복된 숫자중 맨 처음 나오는 숫자는 i와 j가 같으니 출력되고 뒤에있는 중복 숫자는 i가 j까지 증가하기 전에 앞에서 탈출하므로 출력에서 제외됩니다.
			printf("%d %d\n", a[i], cnt[i]); // 제일 먼저 나온 중복된 숫자와 카운트 위치만 출력합니다.
	}

	return 0;
}

=====================================================================================================================================================================================================================
문제 3

#include<stdio.h>
#pragma warning(disable:4996)

int main()
{
	int a[10] = { 0 }; // 최대 10개의 정수를 입력받으므로 입력받을 배열 a[10]을 선언했습니다.
	int n, i, j, tmp; // 배열의 크기를 정할 n과 정렬시 사용할 tmp, 반복문에서 사용할 i, j입니다.

	scanf("%d", &n); // 최대 몇 개의 숫자를 입력받을지 정합니다.

	for (i = 0; i < n; i++)
		scanf("%d", &a[i]); // n번 반복문을 돌려 배열에 저장합니다.

	for (i = 0; i < n - 1; i++) // 조건문 속에 i+1이 있기 때문에 n - 1번 반복합니다.
	{
		for (j = 0; j < n - i - 1; j++) // 반복 마지막엔 가장 큰 수가 저장되므로 반복을 끝가지 할 필요 없이 n - i - 1 번 합니다.
		{
			if (a[j] > a[j + 1]) // 오름차순 정렬을 위해 둘 중 큰 것을 뒤로 미루었습니다.
			{
				tmp = a[j];
				a[j] = a[j + 1]; // a[i]가 더 크다면 a[i]와 a[i+1]을 스왚합니다.
				a[j + 1] = tmp;
			}
		}
	}
	//5월 2일 수업에서 배운 버블정렬을 통해 배열이 오름차순으로 정렬되었습니다.

	printf("%d\n", a[n - 2]); // 마지막 인덱스 전 숫자가 두번째로 큰 정수입니다.
	printf("%d\n", a[1]); // 2번째 위치한 숫자가 두번째로 작은 정수입니다.


	return 0;
}

=====================================================================================================================================================================================================================
문제 4-1

#include<stdio.h>
#pragma warning(disable:4996)
int main()
{	int a[20] = { 0 }; // 최대 20개의 정수를 입력받으므로 입력받을 배열 a를 선언했습니다.
	int n, i; // 배열의 크기를 정할 n과 반복문에서 사용할 i입니다.
	scanf("%d", &n); // 최대 몇 개의 숫자를 입력받을지 정합니다.
	for (i = 0; i < n; i++)
		scanf("%d", &a[i]); // n번 반복문을 돌려 배열에 저장합니다.
	for (i = n - 1; i >= 0; i--) // 마지막 인덱스부터 0까지 출력합니다.
		printf(" %d", a[i]); // 마지막 인덱스부터 출력했기 때문에 거꾸로 출력됩니다.
	return 0;
}

=====================================================================================================================================================================================================================
문제 4-2

#include<stdio.h>
#pragma warning(disable:4996)

int main()
{
	int a[20] = { 0 }; // 최대 20개의 정수를 입력받으므로 입력받을 배열 a를 선언했습니다.
	int n, i, j; // 배열의 크기를 정할 n과 반복문에서 사용할 i입니다.
	int max[7] = { 0 }, min[7] = { 0 }; // 최대, 최소를 저장할 배열입니다. 3개씩 묶어서 max와 min을 구하므로 최대 7개 숫자가 저장됩니다.
	int size = 0 ; // 3씩 묶었을 때 몇 묶음 나오는지 확인하는 size변수입니다.

	scanf("%d", &n); // 최대 몇 개의 숫자를 입력받을지 정합니다.

	for (i = 0; i < n; i++)
		scanf("%d", &a[i]); // n번 반복문을 돌려 배열에 저장합니다.

	for (i = n - 1; i >= 0; i--) // 마지막 인덱스부터 0까지 출력합니다.
		printf(" %d", a[i]); // 마지막 인덱스부터 출력했기 때문에 거꾸로 출력됩니다.
	
	printf("\n");

	if (n % 3 == 0) // n이 3의 배수라면 총 n/3만큼의 묶음이 생깁니다.
		size = n / 3;
	else // 3의 배수가 아니라면 int이기 때문에 내림이 발생해 n / 3 + 1의 묶음이 생깁니다. 
		size = n / 3 + 1;

	for (i = 0; i < size; i++) // 총 묶음의 개수만큼 반복합니다.
	{
		j = 3 * i; // 묶음의 맨 처음은 3*i입니다.
		max[i] = min[i] = a[j]; // 각 묶음의 처음을 max, min배열에 저장합니다.
		while ( j < 3*(i+1) && j < n)
		{ // 묶음의 마지막은 3*(i+1)이며 마지막 묶음의 경우 n-1일 때 끝납니다.
		  // 예를 들어 n이 8이라면 (0,1,2),(3,4,5),(6,7)의 묶음이 생깁니다.

			if (max[i] < a[j])
				max[i] = a[j]; // 더 큰것을 max배열에 저장합니다. 
			
			if (min[i] > a[j])
				min[i] = a[j]; // 더 작은것을 min배열에 저장합니다.
			j++;
		}
	}

	for (i = 0; i < size ; i++) // size만큼 반복하며 max배열을 출력합니다.
		printf(" %d", max[i]);

	printf("\n");
	
	for (i = 0; i < size ; i++) // size만큼 반복하며 min배열을 출력합니다.
		printf(" %d", min[i]);

	return 0;
}

=====================================================================================================================================================================================================================
문제 4-3
#include<stdio.h>
#pragma warning(disable:4996)
int main()
{	int a[20] = { 0 }; // 최대 20개의 정수를 입력받으므로 입력받을 배열 a를 선언했습니다.
	int n, i, j; // 배열의 크기를 정할 n과 반복문에서 사용할 i, j입니다.
	int max[7] = { 0 }, min[7] = { 0 }; // 최대, 최소를 저장할 배열입니다. 3개씩 묶어서 max와 min을 구하므로 최대 7개 숫자가 저장됩니다.
	int size = 0; // 3씩 묶었을 때 몇 묶음 나오는지 확인하는 size변수입니다.
	scanf("%d", &n); // 최대 몇 개의 숫자를 입력받을지 정합니다.
	for (i = 0; i < n; i++)
		scanf("%d", &a[i]); // n번 반복문을 돌려 배열에 저장합니다.
	for (i = n - 1; i >= 0; i--) // 마지막 인덱스부터 0까지 출력합니다.
		printf(" %d", a[i]); // 마지막 인덱스부터 출력했기 때문에 거꾸로 출력됩니다.
	printf("\n");
	if (n % 3 == 0) // n이 3의 배수라면 총 n/3만큼의 묶음이 생깁니다.
		size = n / 3;
	else // 3의 배수가 아니라면 int타입 때문에 내림이 발생해 n / 3 + 1의 묶음이 생깁니다. 
		size = n / 3 + 1;
	for (i = 0; i < size; i++) // 총 묶음의 개수만큼 반복합니다.
	{
		j = 3 * i; // 묶음의 맨 처음은 3*i입니다.
		max[i] = min[i] = a[j]; // 각 묶음의 처음을 max, min배열에 저장합니다.
		while (j < 3 * (i + 1) && j < n)
		{ // 묶음의 마지막은 3*(i+1)이며 마지막 묶음의 경우 n-1일 때 끝납니다.
		  // 예를 들어 n이 8이라면 (0,1,2),(3,4,5),(6,7)의 묶음이 생깁니다.
			if (max[i] < a[j])
				max[i] = a[j]; // 더 큰것을 max배열에 저장합니다. 
			if (min[i] > a[j])
				min[i] = a[j]; // 더 작은것을 min배열에 저장합니다.
			j++;
		}
	}
	// max와 min배열에는 묶음의 순서대로 최댓값과 최솟값이 저장됩니다.
	if (n == 1) // 숫자가 1개만 입력되었을 경우에는 그 숫자가 가장 큰 수이자 가장 작은 수입니다.
	{
		printf("%d\n", max[0]); // 1개만 입력되었으므로 max와 min에는 가장 처음에 a[0]만 저장되어있습니다.
		printf("%d\n", min[0]); 
	}
	while(1) // 무한 반복문을 이용합니다.
	{
		if (n == 0 || n == 1) // n이 1이거나 0이라면 계산이 끝난 것이므로 무한반복문을 탈출합니다.
			break;			  // 예를 들어 묶음의 변화는 18->6->2->0, 19->7->3->1, 20->7->3->1로 변하고 마지막은 항상 0 또는 1입니다.
		for (i = 0; i < size; i++) // size만큼 반복하며 max배열을 출력합니다.
			printf(" %d", max[i]);
		printf("\n");
		for (i = 0; i < size; i++) // size만큼 반복하며 min배열을 출력합니다.
			printf(" %d", min[i]);
		printf("\n");
		
		n = size; // size를 n에 저장해여 다시 반복합니다.
		if (n % 3 == 0) // n이 3의 배수라면 총 n/3만큼의 묶음이 생깁니다.
			size = n / 3;
		else // 3의 배수가 아니라면 int타입 때문에 내림이 발생해 n / 3 + 1의 묶음이 생깁니다. 
			size = n / 3 + 1;
		for (i = 0; i < size; i++) // 총 묶음의 개수만큼 반복합니다.
		{
			j = 3 * i; // 묶음의 맨 처음은 3*i입니다.
			max[i] = max[j]; // max배열은 max[3*i]
			min[i] = min[j]; // min배열은 min[3*i]으로 초기화 합니다.
			while (j < 3 * (i + 1) && j < n)
			{ 
				if (max[i] < max[j]) // max배열은 max만 다시 계산하여
					max[i] = max[j]; // 더 큰것을 max배열에 저장합니다. 
				if (min[i] > min[j]) // min배열은 min만 다시 계산하여
					min[i] = min[j]; // 더 작은것을 min배열에 저장합니다.
				j++;
			}
		}
	}
	return 0;
}

=====================================================================================================================================================================================================================
문제 5-1
#include<stdio.h>
#pragma warning(disable:4996)
int main()
{	int poly[12] ={ 0 }; // 지수의 최대값이 5임으로 최대 6개 항이 입력됩니다. 계수와 지수가 있으므로 최대 12개의 크기가 필요합니다
	int n , i; // 항의 갯수를 저장할 변수 n과 반복문에서 사용할 변수 i입니다.
		scanf("%d", &n); //항의 갯수를 입력합니다.
	for (i = 0; i < n*2; i++) // 항의 갯수*2 만큼 반복문을 돌려 배열에 저장합니다.
		scanf("%d", &poly[i]);
	for (i = 0; i < n * 2; i++)
	{
		if (i % 2 == 0) // 0부터 시작하므로 짝수일 때 계수가
			printf("( %d", poly[i]);
		else // 홀수일 때 지수가 저장된 배열입니다.
			printf(" %d )", poly[i]);
	}
		return 0;
}
=====================================================================================================================================================================================================================
문제 5-2

#include<stdio.h>
#pragma warning(disable:4996)
int main()
{
	int a[12] = { 0 }; // 지수의 최대값이 5임으로 최대 6개 항이 입력됩니다. 계수와 지수가 있으므로 최대 12개의 크기가 필요합니다
	int b[12] = { 0 };  
	int sum[12] = { 0 }; // 다항식 a와 b, 두 다항식을 더할 sum배열입니다.

	int n, m, i, j, k; // 항의 갯수를 저장할 변수 n, m과 반복문, 각 다항식에 인덱스로 사용할 변수 i, j, k입니다.
	
	scanf("%d", &n); //a 다항식의 항 갯수를 입력합니다.
	
	for (i = 0; i < n * 2; i++) // 항의 갯수*2 만큼 반복문을 돌려 배열에 저장합니다.
		scanf("%d", &a[i]);

	scanf("%d", &m); //b 다항식의 항 갯수를 입력합니다.

	for (i = 0; i < m * 2; i++) // 항의 갯수*2 만큼 반복문을 돌려 배열에 저장합니다.
		scanf("%d", &b[i]);
	
	i = j = k = 0;// i, j, k를 0으로 초기화해 다항식 a, b, sum의 인덱스로 사용합니다.  

	while(i < n*2 && j < m*2) // i와 j 둘 중 하나라도 먼저 끝에 도달하면 반복문을 빠져나옵니다.
	{// 계수와 지수를 2개씩 묶음으로 생각했습니다. 

		if (a[i + 1] > b[j + 1]) // a의 지수가 더 큰 경우에는 
		{
			sum[k] = a[i]; //sum의 계수에 a의 계수를
			sum[k+1] = a[i+1]; //sum의 지수에 a의 지수를 저장합니다.
			i += 2; // 한번에 계수와 지수 모두 저장했으므로 2씩 증가시켰습니다.
			k += 2; // 다항식 a를 사용했으므로 i, k를 2 증가시킵니다.
		}
		else if (a[i + 1] < b[j + 1])
		{
			sum[k] = b[j]; // b가 큰 경우에는 sum에 b를 저장합니다.
			sum[k + 1] = b[j + 1];
			j += 2; //이번에는 다항식 b가 저장됬으므로 j와 k를 2씩 증가시킵니다.
			k += 2; 
		}
		else
		{ // 만약 서로 지수가 같다면 
			sum[k] = a[i]+b[j]; // 계수는 a와 b를 더해 저장하고
			sum[k + 1] = b[j + 1]; // 지수는 a, b가 같으므로 두 다항식 아무거나 저장해도 상관 없습니다.
			j += 2;
			i += 2; // 다항식 a와 b모두 사용했으므로 i,j,k모두 2증가시켰습니다.
			k += 2;  
		}
	}
	// 위에서 두 다항식 중 하나라도 먼저 끝나면 반복문이 끝나는 구조이므로 아직 덧셈이 안 끝난 다항식이 남아있습니다.

	while (i < n*2) // i가 n*2보다 작다면 다항식 b기 먼저 끝난 것입니다.
	{
		sum[k] = a[i]; // 따라서 남는 다항식 a의 나머지 부분을 sum에 채웠습니다.
		sum[k + 1] = a[i + 1];
		k += 2;
		i += 2;
	}
	while (j < m*2) // 반대로 a가 먼저 끝나고 b가 끝난 경우도  
	{
		sum[k] = b[j];  // 남는 다항식 b를 sum에 저장시켰습니다.
		sum[k + 1] = b[j + 1];
		j += 2;
		k += 2;
	}
	// 덧셈이 끝났고 sum 배열을 출력합니다.

	for (i = 0; i < k; i++) // sum배열의 총 길이는 k입니다. 
	{
		if (i % 2 == 0) // 0부터 시작하므로 짝수일 때 계수가
			printf("( %d", sum[i]);
		else // 홀수일 때 지수가 저장되어 있습니다.
			printf(" %d )", sum[i]);
	}

	return 0;
}


